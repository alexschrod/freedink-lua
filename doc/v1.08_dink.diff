--- d_canonical	2008-06-26 09:24:48.000000000 +0200
+++ d2_canonical	2008-06-29 19:45:03.000000000 +0200
@@ -22,7 +22,7 @@
 int check_if_move_is_legal (int u);
 void change_dir_to_diag (int *dir);
 int hurt_thing (int h, int damage, int special);
-int but_timer;
+int but_timer = 0;
 int water_timer;
 bool fire_forward;
 int fire_flip;
@@ -54,7 +54,11 @@
   int color = 0;
   if (spr[h].damage == -1)
     {
-      sprintf (crap, "%s", spr[h].text);
+//redink1 fix for : and '%deee bugs?
+
+      strcpy (crap, spr[h].text);
+//sprintf(crap, "%s", spr[h].text);
+
       cr = &crap[0];
       color = 14;
       while (cr[0] == '`')
@@ -198,10 +194,14 @@
       Msg ("Drew map.");
       if (mode > 2)
 	{
+	  fill_screen (0);
 	  draw_map_game_background ();
+	  if (*pupdate_status == 1)
+	    {
 	  draw_status_all ();
 	}
     }
+    }
   return ddrval;
 }				/* restoreAll */
 
@@ -352,7 +352,12 @@
       if (jinfo.dwYpos < 17000)
 	sjoy.up = TRUE;
     }
-pass:if (GetKeyboard (17))
+pass:
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
+      if (GetKeyboard (17))
     sjoy.joybit[1] = TRUE;
   if (GetKeyboard (32))
     sjoy.joybit[2] = TRUE;
@@ -364,5 +369,6 @@
   if (GetKeyboard (55))
     sjoy.joybit[7] = TRUE;
+    }
   for (int x5 = 1; x5 <= 10; x5++)
     sjoy.button[x5] = FALSE;
   for (int x = 1; x <= 10; x++)
@@ -379,6 +387,10 @@
 	    }
 	}
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (39))
     sjoy.right = TRUE;
   if (GetKeyboard (37))
@@ -387,6 +399,7 @@
     sjoy.down = TRUE;
   if (GetKeyboard (38))
     sjoy.up = TRUE;
+    }
   for (int x2 = 1; x2 <= 10; x2++)
     {
       if (sjoy.joybit[x2])
@@ -1566,7 +1686,10 @@
 int
 check_if_move_is_legal (int u)
 {
-  if (spr[u].move_active)
+//redink1 removed so move_nohard is active for all movements, not just active moves.
+
+//if (spr[u].move_active)
+
     if (spr[u].move_nohard == 1)
       return (0);
   if (u == 1)
@@ -2448,7 +2586,11 @@
 
   if (but_timer < thisTickCount)
     {
-      for (x5 = 29; x5 < 256; x5++)
+//redink1 Only accept keyboard input when console is not active.
+
+      if (mConsoleActive == false)
+	{
+	  for (x5 = 29; x5 < 255; x5++)
 	{
 	  if (x5 == 32)
 	    x5++;
@@ -2576,6 +2759,10 @@
 	      return;
 	    }
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (66))
     {
       ResumeMidi ();
@@ -2584,6 +2771,7 @@
     {
       PauseMidi ();
     }
+    }
   if (spr[h].skip > 0)
     if (spr[h].skip <= spr[h].skiptimer)
       {
@@ -3117,31 +3313,32 @@
       Msg ("error with getting entries");
       return;
     }
+      int lValue = (thisTickCount - lastTickCount) / 2;
   for (int kk = 1; kk < 256; kk++)
     {
       if (pe[kk].peBlue != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peBlue > 10)
-	    pe[kk].peBlue -= 10;
+	      if (pe[kk].peBlue > lValue)
+		pe[kk].peBlue -= lValue;
 	  else
-	    pe[kk].peBlue--;
+		pe[kk].peBlue = 0;
 	}
       if (pe[kk].peGreen != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peGreen > 10)
-	    pe[kk].peGreen -= 10;
+	      if (pe[kk].peGreen > lValue)
+		pe[kk].peGreen -= lValue;
 	  else
-	    pe[kk].peGreen--;
+		pe[kk].peGreen = 0;
 	}
       if (pe[kk].peRed != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peRed > 10)
-	    pe[kk].peRed -= 10;
+	      if (pe[kk].peRed > lValue)
+		pe[kk].peRed -= lValue;
 	  else
-	    pe[kk].peRed--;
+		pe[kk].peRed = 0;
 	}
     }
   lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
@@ -3358,6 +3805,9 @@
 		draw_box (box, 33);
 	      if (inside_box (spr[h].x, spr[h].y, box))
 		{
+//redink1 addition for fixing missle_source problems
+
+		  *pmissle_source = h;
 		  if (spr[i].nohit == 1)
 		    {
 		      if (spr[i].script > 0)
@@ -4601,7 +5047,10 @@
       bActive = wParam;
       break;
     case WM_SETCURSOR:
+      if (!windowed)
+	{
       SetCursor (NULL);
+	}
       return TRUE;
     case WM_CREATE:
       break;
@@ -4610,18 +5059,106 @@
       PostQuitMessage (0);
       break;
     case WM_KEYDOWN:
+      if (mConsoleActive)
+	{
       switch (wParam)
 	{			/*case VK_F1: { Msg("F1 pressed"); 
 				   //g_pMouse->Unacquire();
 
 	     int crap; } break; case VK_F3: { fill_whole_hard(); fill_hard_sprites(); fill_back_sprites(); } break; *//*case VK_F4: { process_downcycle = true; cycle_clock = thisTickCount; } */
+	    case VK_UP:
+	      if (mConsoleHistoryIndex > 0)
+		{
+		  mConsoleHistoryIndex -= 1;
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
 	  break;
+	    case VK_DOWN:
+	      mConsoleHistoryIndex += 1;
+	      if (mConsoleHistoryIndex < mConsoleLineHistory.size ())
+		{
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
+	      else
+		{
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		  mConsoleLine = "";
 	}
       break;
-// case WM_DESTROY:
-
-// finiObjects();
+	    default:
+	      break;
+	    }
+	}
+      break;
+// redink1 addition of console
 
-// PostQuitMessage( 0 );
+    case WM_CHAR:
+      if (mConsoleActive)
+	{
+	  switch (wParam)
+	    {
+	    case 0x08:		// Process a backspace.
+	      if (mConsoleLine.length () > 0)
+		{
+		  mConsoleLine =
+		    mConsoleLine.substr (0, mConsoleLine.length () - 1);
+		}
+	      break;
+	    case 0x0A:		// Process a linefeed
+	      break;
+	    case 0x1B:		// Process an escape. 
+	      mConsoleActive = false;
+	      mConsoleLine = "";
+	      break;
+	    case 0x09:		// Process a tab. 
+	      break;
+	    case 0x0D:		// Process a carriage return, try to parse the string.
+	      if (mConsoleScript == 0 || rbuf[mConsoleScript] == NULL)
+		{
+		  mConsoleScript = 0;
+		  for (int k = 1; k < max_scripts; k++)
+		    {
+		      if (rbuf[k] == NULL)
+			{
+			  mConsoleScript = k;
+			  rinfo[mConsoleScript] =
+			    (struct refinfo *)
+			    malloc (sizeof (struct refinfo));
+			  memset (rinfo[mConsoleScript], 0,
+				  sizeof (struct refinfo));
+			  rinfo[mConsoleScript]->sprite = 1000;
+			  rinfo[mConsoleScript]->level = 1;
+			  rbuf[mConsoleScript] = (char *) malloc (255);
+			  break;
+			}
+		    }
+		}
+	      if (mConsoleScript != 0)
+		{
+		  strncpy (rbuf[mConsoleScript], mConsoleLine.c_str (), 254);
+		  process_line (mConsoleScript, rbuf[mConsoleScript], false);
+		  mConsoleReturnValue = returnint;
+		  mConsoleLineHistory.push_back (mConsoleLine);
+		  if (mConsoleLineHistory.size () > 20)
+		    {
+		      mConsoleLineHistory.erase (mConsoleLineHistory.
+						 begin ());
+		    }
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		}
+	      mConsoleLine = "";
+	      break;
+	    default:		// Process displayable characters.
+	      mConsoleLine += static_cast < char >(wParam);
+	      break;
+	    }
+// clear keyboard buffer
 
-// break;
+	  for (int x = 0; x < 256; x++)
+	    {
+	      if (GetKeyboard (x))
+		{
+		}
+	    }
+	}
+      break;
@@ -4715,7 +5270,7 @@
 	}
       if (strnicmp (shit, "-nojoy", strlen ("-nojoy")) == 0)
 	{
-	  joystick = false;
+	  disablejoystick = TRUE;
 	}
       if (strnicmp (shit, "-noini", strlen ("-noini")) == 0)
 	{
@@ -5029,6 +5778,8 @@
   if (cd_inserted)
     PlayCD (g_hWnd, 7);
 #endif
+  if (disablejoystick == FALSE)
+    {
   if (CheckJoyStickPresent () == FALSE)
     {
 // return initFail(hwnd, "Could not init the joystick.");
@@ -5039,6 +5790,7 @@
     {
       joystick = TRUE;
     }
+    }
   rcRect.left = 0;
   rcRect.top = 0;
   rcRect.right = x;
@@ -5158,6 +5910,8 @@
   attach ();
 //init_mouse(hwnd);
 
+  memset (&spr, NULL, sizeof (spr));
@@ -5346,6 +6100,7 @@
 	{
 	  if (g_b_kill_app == false)
 	    {
+	      SetFocus (hwnd);
 	      updateFrame ();
 	    }
 //WaitMessage();
@@ -5355,6 +6110,8 @@
 	{
 // make sure we go to sleep if we have nothing else to do
 
+	  Sleep (1);
+	  SetFocus (NULL);
 	  WaitMessage ();
 	}
     }
