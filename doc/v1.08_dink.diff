--- d_canonical	2008-06-26 09:24:48.000000000 +0200
+++ d2_canonical	2008-06-29 19:45:03.000000000 +0200
@@ -352,7 +352,12 @@
       if (jinfo.dwYpos < 17000)
 	sjoy.up = TRUE;
     }
-pass:if (GetKeyboard (17))
+pass:
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
+      if (GetKeyboard (17))
     sjoy.joybit[1] = TRUE;
   if (GetKeyboard (32))
     sjoy.joybit[2] = TRUE;
@@ -364,5 +369,6 @@
   if (GetKeyboard (55))
     sjoy.joybit[7] = TRUE;
+    }
   for (int x5 = 1; x5 <= 10; x5++)
     sjoy.button[x5] = FALSE;
   for (int x = 1; x <= 10; x++)
@@ -379,6 +387,10 @@
 	    }
 	}
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (39))
     sjoy.right = TRUE;
   if (GetKeyboard (37))
@@ -387,6 +399,7 @@
     sjoy.down = TRUE;
   if (GetKeyboard (38))
     sjoy.up = TRUE;
+    }
   for (int x2 = 1; x2 <= 10; x2++)
     {
       if (sjoy.joybit[x2])
@@ -2448,7 +2586,11 @@
 
   if (but_timer < thisTickCount)
     {
-      for (x5 = 29; x5 < 256; x5++)
+//redink1 Only accept keyboard input when console is not active.
+
+      if (mConsoleActive == false)
+	{
+	  for (x5 = 29; x5 < 255; x5++)
 	{
 	  if (x5 == 32)
 	    x5++;
@@ -2576,6 +2759,10 @@
 	      return;
 	    }
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (66))
     {
       ResumeMidi ();
@@ -2584,6 +2771,7 @@
     {
       PauseMidi ();
     }
+    }
   if (spr[h].skip > 0)
     if (spr[h].skip <= spr[h].skiptimer)
       {
@@ -3117,31 +3313,32 @@
       Msg ("error with getting entries");
       return;
     }
+      int lValue = (thisTickCount - lastTickCount) / 2;
   for (int kk = 1; kk < 256; kk++)
     {
       if (pe[kk].peBlue != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peBlue > 10)
-	    pe[kk].peBlue -= 10;
+	      if (pe[kk].peBlue > lValue)
+		pe[kk].peBlue -= lValue;
 	  else
-	    pe[kk].peBlue--;
+		pe[kk].peBlue = 0;
 	}
       if (pe[kk].peGreen != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peGreen > 10)
-	    pe[kk].peGreen -= 10;
+	      if (pe[kk].peGreen > lValue)
+		pe[kk].peGreen -= lValue;
 	  else
-	    pe[kk].peGreen--;
+		pe[kk].peGreen = 0;
 	}
       if (pe[kk].peRed != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peRed > 10)
-	    pe[kk].peRed -= 10;
+	      if (pe[kk].peRed > lValue)
+		pe[kk].peRed -= lValue;
 	  else
-	    pe[kk].peRed--;
+		pe[kk].peRed = 0;
 	}
     }
   lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
@@ -3358,6 +3805,9 @@
 		draw_box (box, 33);
 	      if (inside_box (spr[h].x, spr[h].y, box))
 		{
+//redink1 addition for fixing missle_source problems
+
+		  *pmissle_source = h;
 		  if (spr[i].nohit == 1)
 		    {
 		      if (spr[i].script > 0)
@@ -4610,18 +5059,106 @@
       PostQuitMessage (0);
       break;
     case WM_KEYDOWN:
+      if (mConsoleActive)
+	{
       switch (wParam)
 	{			/*case VK_F1: { Msg("F1 pressed"); 
 				   //g_pMouse->Unacquire();
 
 	     int crap; } break; case VK_F3: { fill_whole_hard(); fill_hard_sprites(); fill_back_sprites(); } break; *//*case VK_F4: { process_downcycle = true; cycle_clock = thisTickCount; } */
+	    case VK_UP:
+	      if (mConsoleHistoryIndex > 0)
+		{
+		  mConsoleHistoryIndex -= 1;
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
 	  break;
+	    case VK_DOWN:
+	      mConsoleHistoryIndex += 1;
+	      if (mConsoleHistoryIndex < mConsoleLineHistory.size ())
+		{
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
+	      else
+		{
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		  mConsoleLine = "";
 	}
       break;
-// case WM_DESTROY:
-
-// finiObjects();
+	    default:
+	      break;
+	    }
+	}
+      break;
+// redink1 addition of console
 
-// PostQuitMessage( 0 );
+    case WM_CHAR:
+      if (mConsoleActive)
+	{
+	  switch (wParam)
+	    {
+	    case 0x08:		// Process a backspace.
+	      if (mConsoleLine.length () > 0)
+		{
+		  mConsoleLine =
+		    mConsoleLine.substr (0, mConsoleLine.length () - 1);
+		}
+	      break;
+	    case 0x0A:		// Process a linefeed
+	      break;
+	    case 0x1B:		// Process an escape. 
+	      mConsoleActive = false;
+	      mConsoleLine = "";
+	      break;
+	    case 0x09:		// Process a tab. 
+	      break;
+	    case 0x0D:		// Process a carriage return, try to parse the string.
+	      if (mConsoleScript == 0 || rbuf[mConsoleScript] == NULL)
+		{
+		  mConsoleScript = 0;
+		  for (int k = 1; k < max_scripts; k++)
+		    {
+		      if (rbuf[k] == NULL)
+			{
+			  mConsoleScript = k;
+			  rinfo[mConsoleScript] =
+			    (struct refinfo *)
+			    malloc (sizeof (struct refinfo));
+			  memset (rinfo[mConsoleScript], 0,
+				  sizeof (struct refinfo));
+			  rinfo[mConsoleScript]->sprite = 1000;
+			  rinfo[mConsoleScript]->level = 1;
+			  rbuf[mConsoleScript] = (char *) malloc (255);
+			  break;
+			}
+		    }
+		}
+	      if (mConsoleScript != 0)
+		{
+		  strncpy (rbuf[mConsoleScript], mConsoleLine.c_str (), 254);
+		  process_line (mConsoleScript, rbuf[mConsoleScript], false);
+		  mConsoleReturnValue = returnint;
+		  mConsoleLineHistory.push_back (mConsoleLine);
+		  if (mConsoleLineHistory.size () > 20)
+		    {
+		      mConsoleLineHistory.erase (mConsoleLineHistory.
+						 begin ());
+		    }
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		}
+	      mConsoleLine = "";
+	      break;
+	    default:		// Process displayable characters.
+	      mConsoleLine += static_cast < char >(wParam);
+	      break;
+	    }
+// clear keyboard buffer
 
-// break;
+	  for (int x = 0; x < 256; x++)
+	    {
+	      if (GetKeyboard (x))
+		{
+		}
+	    }
+	}
+      break;
