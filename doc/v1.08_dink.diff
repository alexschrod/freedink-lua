--- d_canonical	2008-06-26 09:24:48.000000000 +0200
+++ d2_canonical	2008-06-29 19:45:03.000000000 +0200
@@ -22,7 +22,7 @@
 int check_if_move_is_legal (int u);
 void change_dir_to_diag (int *dir);
 int hurt_thing (int h, int damage, int special);
-int but_timer;
+int but_timer = 0;
 int water_timer;
 bool fire_forward;
 int fire_flip;
@@ -54,7 +54,11 @@
   int color = 0;
   if (spr[h].damage == -1)
     {
-      sprintf (crap, "%s", spr[h].text);
+//redink1 fix for : and '%deee bugs?
+
+      strcpy (crap, spr[h].text);
+//sprintf(crap, "%s", spr[h].text);
+
       cr = &crap[0];
       color = 14;
       while (cr[0] == '`')
@@ -198,10 +194,14 @@
       Msg ("Drew map.");
       if (mode > 2)
 	{
+	  fill_screen (0);
 	  draw_map_game_background ();
+	  if (*pupdate_status == 1)
+	    {
 	  draw_status_all ();
 	}
     }
+    }
   return ddrval;
 }				/* restoreAll */
 
@@ -352,7 +352,12 @@
       if (jinfo.dwYpos < 17000)
 	sjoy.up = TRUE;
     }
-pass:if (GetKeyboard (17))
+pass:
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
+      if (GetKeyboard (17))
     sjoy.joybit[1] = TRUE;
   if (GetKeyboard (32))
     sjoy.joybit[2] = TRUE;
@@ -364,8 +369,11 @@
     sjoy.joybit[5] = TRUE;
   if (GetKeyboard (54))
     sjoy.joybit[6] = TRUE;
+      if (GetKeyboard (77))
+	sjoy.joybit[6] = TRUE;
   if (GetKeyboard (55))
     sjoy.joybit[7] = TRUE;
+    }
   for (int x5 = 1; x5 <= 10; x5++)
     sjoy.button[x5] = FALSE;
   for (int x = 1; x <= 10; x++)
@@ -379,6 +387,10 @@
 	    }
 	}
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (39))
     sjoy.right = TRUE;
   if (GetKeyboard (37))
@@ -387,6 +399,7 @@
     sjoy.down = TRUE;
   if (GetKeyboard (38))
     sjoy.up = TRUE;
+    }
   for (int x2 = 1; x2 <= 10; x2++)
     {
       if (sjoy.joybit[x2])
@@ -659,6 +672,9 @@
 	    add_sprite (spr[h].x, spr[h].y, 5, spr[h].base_walk + 5, 1);
 	  spr[crap2].speed = 0;
 	  spr[crap2].seq = spr[h].base_walk + 5;
+//redink1 added this so corpses are the same size
+
+	  spr[crap2].size = spr[h].size;
 	  return;
 	}
       else
@@ -1566,11 +1686,14 @@
 int
 check_if_move_is_legal (int u)
 {
-  if (spr[u].move_active)
+//redink1 removed so move_nohard is active for all movements, not just active moves.
+
+//if (spr[u].move_active)
+
     if (spr[u].move_nohard == 1)
       return (0);
   if (u == 1)
-    if (in_this_base (spr[u].seq, 310))
+    if (in_this_base (spr[u].seq, mDinkBasePush))
       return (0);
   if (u == 1)
     if (!no_cheat)
@@ -2387,7 +2514,7 @@
   if (play.push_active)
     if (play.push_timer + 600 < thisTickCount)
       {
-	spr[h].seq = 310 + spr[h].dir;
+	spr[h].seq = mDinkBasePush + spr[h].dir;
 	spr[h].frame = 1;
 	spr[h].nocontrol = true;
 //play.push_active = false;
@@ -2399,6 +2526,15 @@
     {
       if (!run_through_tag_list_talk (h))
 	{
+//redink1 addition of 'not talking to anything' script
+
+	  int sc = load_script ("DNOTALK", 0, false);
+	  if (sc != 0 && locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	    }
+	  else
+	    {
 	  kill_text_owned_by (h);
 	  int randy = (rand () % 6) + 1;
 #ifdef __GERMAN
@@ -2433,6 +2570,7 @@
 #endif
 	}
     }
+    }
   if ((sjoy.button[1] == TRUE) && (weapon_script != 0))
     {
       if (spr[h].base_hit > 0)
@@ -2448,7 +2586,11 @@
 
   if (but_timer < thisTickCount)
     {
-      for (x5 = 29; x5 < 256; x5++)
+//redink1 Only accept keyboard input when console is not active.
+
+      if (mConsoleActive == false)
+	{
+	  for (x5 = 29; x5 < 255; x5++)
 	{
 	  if (x5 == 32)
 	    x5++;
@@ -2480,15 +2622,42 @@
 	    }
 	}
     }
-  if ((sjoy.button[6] == TRUE)
-      || ((GetKeyboard (77)) && (but_timer < thisTickCount)))
+    }
+  if (sjoy.button[6] == TRUE)
     {
-      but_timer = thisTickCount + 200;
       int mycrap = load_script ("BUTTON6", 1, false);
       if (locate (mycrap, "MAIN"))
 	run_script (mycrap);
       goto b1end;
     }
+  if (sjoy.button[7] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON7", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[8] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON8", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[9] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON9", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[10] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON10", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
   if (magic_script != 0)
     if (sjoy.joybit[3])
       goto shootm;
@@ -2496,10 +2665,21 @@
     {
       if (magic_script == 0)
 	{
+//redink1 addition of 'no magic' script
+
+	  int sc = load_script ("DNOMAGIC", 0, false);
+	  if (sc != 0 && locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	    }
+	  else
+	    {
 	  int randy = (rand () % 6) + 1;
 	  kill_text_owned_by (h);
 #ifdef __GERMAN
-	  if (randy == 3)
+
+//if (randy == 3) 
+
 	    if (randy == 1)
 	      say_text
 		("`$Ich muß erst die Magie erlernen, bevor ich dies ausprobieren kann..",
@@ -2521,8 +2701,9 @@
 	  if (randy == 5)
 	    say_text ("`$Nothing happened.", h, 0);
 	  if (randy == 6)
 	    say_text ("`$Hocus pocus!", h, 0);
 #endif
+	    }
 	  goto b1end;
 	}
 //player pressed 1
@@ -2544,25 +2726,26 @@
     }
   if (sjoy.button[4])
     {
+//redink1 addition of 'enter key/inventory' script
+
+      int sc = load_script ("BUTTON4", 0, false);
+      if (sc != 0)
+	{
+	  if (locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	      return;
+	    }
+	}
       item_screen = true;
       SoundPlayEffect (18, 22050, 0, 0, 0);
       return;
-    }
-  if (GetKeyboard (50))
-    {
-      if (!no_cheat)
-	{
+    }				/*if ( GetKeyboard(50) ) { if (!no_cheat) { 
 //player pressed 2
 
 //lets add a duck with brain 2
 
-	  crap = add_sprite (spr[h].x - 20, spr[h].y - 50, 3, 26, 1);
-	  spr[crap].speed = 1;
-	  spr[crap].base_walk = 20;
-	  spr[crap].exp = 11;
-	  spr[crap].hitpoints = 5;
-	}
-    }
+				   crap = add_sprite(spr[h].x-20,spr[h].y-50,3,26,1); spr[crap].speed = 1; spr[crap].base_walk = 20; spr[crap].exp = 11; spr[crap].hitpoints = 5; } } */
   if ((sjoy.button[5] == TRUE))
     {
       if (!showb.active)
@@ -2576,6 +2759,10 @@
 	      return;
 	    }
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (66))
     {
       ResumeMidi ();
@@ -2584,6 +2771,7 @@
     {
       PauseMidi ();
     }
+    }
   if (spr[h].skip > 0)
     if (spr[h].skip <= spr[h].skiptimer)
       {
@@ -3109,6 +3297,14 @@
 void
 CyclePalette ()
 {
+//redink1 truecolor fadedown...
+
+  if (truecolor)
+    {
+      process_downcycle = true;
+    }
+  else
+    {
   int reg[15];
   int k;
   bool done_this_time = true;
@@ -3117,31 +3313,32 @@
       Msg ("error with getting entries");
       return;
     }
+      int lValue = (thisTickCount - lastTickCount) / 2;
   for (int kk = 1; kk < 256; kk++)
     {
       if (pe[kk].peBlue != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peBlue > 10)
-	    pe[kk].peBlue -= 10;
+	      if (pe[kk].peBlue > lValue)
+		pe[kk].peBlue -= lValue;
 	  else
-	    pe[kk].peBlue--;
+		pe[kk].peBlue = 0;
 	}
       if (pe[kk].peGreen != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peGreen > 10)
-	    pe[kk].peGreen -= 10;
+	      if (pe[kk].peGreen > lValue)
+		pe[kk].peGreen -= lValue;
 	  else
-	    pe[kk].peGreen--;
+		pe[kk].peGreen = 0;
 	}
       if (pe[kk].peRed != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peRed > 10)
-	    pe[kk].peRed -= 10;
+	      if (pe[kk].peRed > lValue)
+		pe[kk].peRed -= lValue;
 	  else
-	    pe[kk].peRed--;
+		pe[kk].peRed = 0;
 	}
     }
   lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
@@ -3163,13 +3360,21 @@
 	    }
 	}
     }
-} void
+}} void
 
 up_cycle (void)
 {
+//redink1 added this for true-color fade support
+
+  if (truecolor)
+    {
+      process_upcycle = true;
+    }
+  else
+    {
   bool donethistime = true;
   if (lpDDPal->GetEntries (0, 0, 256, pe) != DD_OK)
     {
       Msg ("error with getting entries");
       return;
     }
@@ -3224,7 +3431,7 @@
 	    run_script (junk);
 	  }
       }
-} void
+}} void
 
 draw_box (RECT box, int color)
 {
@@ -3280,6 +3726,7 @@
       SetRect (&rcRectSrc, 0, 0, 640, 480);
       ddbltfx.dwSize = sizeof (ddbltfx);
       ddbltfx.dwDDFX = DDBLTFX_NOTEARING;
+      lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
       ddrval =
 	lpDDSPrimary->Blt (&rcRectDest, lpDDSBack, &rcRectSrc,
 			   DDBLT_DDFX | DDBLT_WAIT, &ddbltfx);
@@ -3358,6 +3805,9 @@
 		draw_box (box, 33);
 	      if (inside_box (spr[h].x, spr[h].y, box))
 		{
+//redink1 addition for fixing missle_source problems
+
+		  *pmissle_source = h;
 		  if (spr[i].nohit == 1)
 		    {
 		      if (spr[i].script > 0)
@@ -4446,20 +4893,19 @@
     {
 //let's display a nice dot to mark where they are on the map
 
-      int x = play.last_map;
+      int x = play.last_map - 1;
       int mseq = 165;
       showb.picframe++;
       if (showb.picframe > index[mseq].last)
 	showb.picframe = 1;
       int mframe = showb.picframe;
-      lpDDSBack->BltFast (((x) * 20 - ((x / 32) * 640)) - 20, (x / 32) * 20,
+      lpDDSBack->BltFast ((x % 32) * 20, (x / 32) * 20,
 			  k[seq[mseq].frame[mframe]].k,
 			  &k[seq[mseq].frame[mframe]].box,
 			  DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT);
     }
   if ((sjoy.button[1]) || (sjoy.button[2]) || (sjoy.button[3])
-      || (sjoy.button[4]) || (sjoy.button[5]) || (sjoy.button[6])
-      || ((GetKeyboard (77)) && (but_timer < thisTickCount)))
+      || (sjoy.button[4]) || (sjoy.button[5]) || (sjoy.button[6]))
     {
       showb.active = false;
       if (showb.script != 0)
@@ -4601,7 +5047,10 @@
       bActive = wParam;
       break;
     case WM_SETCURSOR:
+      if (!windowed)
+	{
       SetCursor (NULL);
+	}
       return TRUE;
     case WM_CREATE:
       break;
@@ -4610,18 +5059,106 @@
       PostQuitMessage (0);
       break;
     case WM_KEYDOWN:
+      if (mConsoleActive)
+	{
       switch (wParam)
 	{			/*case VK_F1: { Msg("F1 pressed"); 
 				   //g_pMouse->Unacquire();
 
 	     int crap; } break; case VK_F3: { fill_whole_hard(); fill_hard_sprites(); fill_back_sprites(); } break; *//*case VK_F4: { process_downcycle = true; cycle_clock = thisTickCount; } */
+	    case VK_UP:
+	      if (mConsoleHistoryIndex > 0)
+		{
+		  mConsoleHistoryIndex -= 1;
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
 	  break;
+	    case VK_DOWN:
+	      mConsoleHistoryIndex += 1;
+	      if (mConsoleHistoryIndex < mConsoleLineHistory.size ())
+		{
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
+	      else
+		{
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		  mConsoleLine = "";
 	}
       break;
-// case WM_DESTROY:
-
-// finiObjects();
+	    default:
+	      break;
+	    }
+	}
+      break;
+// redink1 addition of console
 
-// PostQuitMessage( 0 );
+    case WM_CHAR:
+      if (mConsoleActive)
+	{
+	  switch (wParam)
+	    {
+	    case 0x08:		// Process a backspace.
+	      if (mConsoleLine.length () > 0)
+		{
+		  mConsoleLine =
+		    mConsoleLine.substr (0, mConsoleLine.length () - 1);
+		}
+	      break;
+	    case 0x0A:		// Process a linefeed
+	      break;
+	    case 0x1B:		// Process an escape. 
+	      mConsoleActive = false;
+	      mConsoleLine = "";
+	      break;
+	    case 0x09:		// Process a tab. 
+	      break;
+	    case 0x0D:		// Process a carriage return, try to parse the string.
+	      if (mConsoleScript == 0 || rbuf[mConsoleScript] == NULL)
+		{
+		  mConsoleScript = 0;
+		  for (int k = 1; k < max_scripts; k++)
+		    {
+		      if (rbuf[k] == NULL)
+			{
+			  mConsoleScript = k;
+			  rinfo[mConsoleScript] =
+			    (struct refinfo *)
+			    malloc (sizeof (struct refinfo));
+			  memset (rinfo[mConsoleScript], 0,
+				  sizeof (struct refinfo));
+			  rinfo[mConsoleScript]->sprite = 1000;
+			  rinfo[mConsoleScript]->level = 1;
+			  rbuf[mConsoleScript] = (char *) malloc (255);
+			  break;
+			}
+		    }
+		}
+	      if (mConsoleScript != 0)
+		{
+		  strncpy (rbuf[mConsoleScript], mConsoleLine.c_str (), 254);
+		  process_line (mConsoleScript, rbuf[mConsoleScript], false);
+		  mConsoleReturnValue = returnint;
+		  mConsoleLineHistory.push_back (mConsoleLine);
+		  if (mConsoleLineHistory.size () > 20)
+		    {
+		      mConsoleLineHistory.erase (mConsoleLineHistory.
+						 begin ());
+		    }
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		}
+	      mConsoleLine = "";
+	      break;
+	    default:		// Process displayable characters.
+	      mConsoleLine += static_cast < char >(wParam);
+	      break;
+	    }
+// clear keyboard buffer
 
-// break;
+	  for (int x = 0; x < 256; x++)
+	    {
+	      if (GetKeyboard (x))
+		{
+		}
+	    }
+	}
+      break;
@@ -4715,7 +5270,7 @@
 	}
       if (strnicmp (shit, "-nojoy", strlen ("-nojoy")) == 0)
 	{
-	  joystick = false;
+	  disablejoystick = TRUE;
 	}
       if (strnicmp (shit, "-noini", strlen ("-noini")) == 0)
 	{
@@ -5029,6 +5778,8 @@
   if (cd_inserted)
     PlayCD (g_hWnd, 7);
 #endif
+  if (disablejoystick == FALSE)
+    {
   if (CheckJoyStickPresent () == FALSE)
     {
 // return initFail(hwnd, "Could not init the joystick.");
@@ -5039,6 +5790,7 @@
     {
       joystick = TRUE;
     }
+    }
   rcRect.left = 0;
   rcRect.top = 0;
   rcRect.right = x;
@@ -5158,6 +5910,8 @@
   attach ();
 //init_mouse(hwnd);
 
+  memset (&spr, NULL, sizeof (spr));
@@ -5346,6 +6100,7 @@
 	{
 	  if (g_b_kill_app == false)
 	    {
+	      SetFocus (hwnd);
 	      updateFrame ();
 	    }
 //WaitMessage();
@@ -5355,6 +6110,8 @@
 	{
 // make sure we go to sleep if we have nothing else to do
 
+	  Sleep (1);
+	  SetFocus (NULL);
 	  WaitMessage ();
 	}
     }
